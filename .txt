Applying textures to the walls in a first-person shooter game using raycasting with MiniLibX involves several steps. Here's a step-by-step guide to help you get started.

Step-by-Step Guide
Load the Texture Files:

MiniLibX supports loading XPM files directly, but for PNG or other formats, you might need additional libraries like libpng or convert them to XPM format.
Initialize MiniLibX:

Set up your MiniLibX environment and load the texture images into memory.
Cast Rays:

Perform the raycasting to determine which walls are hit and where.
Calculate Texture Coordinates:

For each vertical stripe of the wall, calculate the corresponding texture coordinate and extract the texture color.
Draw the Textured Wall:

Use the calculated texture coordinates to apply the texture to the wall slices.
Example Code
Here is a simplified example assuming you have a basic raycasting setup:

1. Include MiniLibX Headers
c
Copy code
#include <mlx.h>
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
2. Define Global Variables
c
Copy code
#define screenWidth 640
#define screenHeight 480

typedef struct  s_img {
    void    *img_ptr;
    int     *data;
    int     width;
    int     height;
    int     bpp;
    int     size_line;
    int     endian;
}               t_img;

typedef struct  s_data {
    void    *mlx_ptr;
    void    *win_ptr;
    t_img   texture[4]; // Assuming 4 textures
}               t_data;

t_data  g_data;
3. Load Texture Files
c
Copy code
void    load_texture(t_img *texture, char *file_path)
{
    texture->img_ptr = mlx_xpm_file_to_image(g_data.mlx_ptr, file_path, &texture->width, &texture->height);
    if (!texture->img_ptr)
    {
        printf("Error loading texture: %s\n", file_path);
        exit(1);
    }
    texture->data = (int *)mlx_get_data_addr(texture->img_ptr, &texture->bpp, &texture->size_line, &texture->endian);
}

void    load_textures()
{
    load_texture(&g_data.texture[0], "path/to/texture1.xpm");
    load_texture(&g_data.texture[1], "path/to/texture2.xpm");
    load_texture(&g_data.texture[2], "path/to/texture3.xpm");
    load_texture(&g_data.texture[3], "path/to/texture4.xpm");
}
4. Initialize MiniLibX
c
Copy code
void    init()
{
    g_data.mlx_ptr = mlx_init();
    g_data.win_ptr = mlx_new_window(g_data.mlx_ptr, screenWidth, screenHeight, "Raycasting with Textures");
    load_textures();
}
5. Cast Rays and Apply Textures
c
Copy code
void    apply_texture(int x, int drawStart, int drawEnd, int texNum, double wallX)
{
    int texWidth = g_data.texture[texNum].width;
    int texHeight = g_data.texture[texNum].height;
    int texX = (int)(wallX * (double)texWidth);
    if (side == 0 && rayDirX > 0) texX = texWidth - texX - 1;
    if (side == 1 && rayDirY < 0) texX = texWidth - texX - 1;

    for (int y = drawStart; y < drawEnd; y++)
    {
        int d = y * 256 - screenHeight * 128 + lineHeight * 128;
        int texY = ((d * texHeight) / lineHeight) / 256;
        int color = g_data.texture[texNum].data[texY * texWidth + texX];
        buffer[y][x] = color; // Assuming you have a buffer to store pixels
    }
}

void    cast_ray(int x)
{
    // Perform raycasting logic to find the wall hit and calculate distance, etc.

    // Example values:
    int drawStart = ...;
    int drawEnd = ...;
    int texNum = ...; // The texture index
    double wallX = ...; // Exact x-coordinate on the texture

    apply_texture(x, drawStart, drawEnd, texNum, wallX);
}
6. Render the Scene
c
Copy code
void    render()
{
    for (int x = 0; x < screenWidth; x++)
    {
        cast_ray(x);
    }

    // Display the buffer on the screen
    mlx_put_image_to_window(g_data.mlx_ptr, g_data.win_ptr, g_data.img.img_ptr, 0, 0);
}
7. Main Function
c
Copy code
int main()
{
    init();
    while (1)
    {
        render();
        mlx_loop(g_data.mlx_ptr);
    }
    return 0;
}
Explanation
Loading Textures:

Use mlx_xpm_file_to_image to load XPM textures into MiniLibX images.
Retrieve the image data with mlx_get_data_addr.
Raycasting:

For each column (x), cast a ray to determine where it hits a wall.
Calculate drawStart and drawEnd to find the portion of the column to draw the wall.
Applying Textures:

Compute texture coordinates (texX, texY) for the current wall slice.
Fetch the corresponding color from the texture and store it in the buffer.
Rendering:

Loop over all columns, casting rays and applying textures.
Use mlx_put_image_to_window to display the final image.
This is a simplified overview. In a complete implementation, you would also handle user input, game logic, and optimizations. Make sure to include appropriate error checking and memory management as needed.






